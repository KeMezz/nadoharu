---
name: resolve-pr-review
description: >
  PR의 리뷰 코멘트를 확인하고, 미해결 코멘트를 수집하여 타당성을 분석한 뒤
  코드/문서를 수정하거나 반론을 작성하여 각 코멘트에 직접 리플을 답니다.
  트리거: "resolve review", "리뷰 대응", "코멘트 해결", "리뷰 반영"
metadata:
  author: hyeongjin
  version: "1.0"
---

# Resolve PR Review

PR의 리뷰 코멘트를 확인하고, 미해결 코멘트에 대해 수정 또는 반론으로 대응한 뒤 GitHub에 리플을 등록한다.

**Input**: PR 번호 또는 GitHub PR URL. 없으면 현재 브랜치의 열린 PR을 자동 감지.

## Steps

### 1. PR 정보 및 리뷰 코멘트 수집

#### 1-1. PR 기본 정보

```bash
gh pr view <PR번호> --json title,state,headRefName,baseRefName,url
```

PR이 OPEN 상태인지 확인한다. MERGED/CLOSED이면 사용자에게 알리고 중단한다.

#### 1-2. 리뷰 코멘트 전체 수집

```bash
# 리뷰 단위 코멘트 (전체 리뷰 본문)
gh api repos/<owner>/<repo>/pulls/<PR번호>/reviews

# 인라인 리뷰 코멘트 (파일별 라인 코멘트)
gh api repos/<owner>/<repo>/pulls/<PR번호>/comments

# 일반 이슈 코멘트 (PR 대화)
gh api repos/<owner>/<repo>/issues/<PR번호>/comments
```

각 코멘트에서 수집할 정보:
- `id`: 코멘트 고유 ID (리플 시 필요)
- `body`: 코멘트 본문
- `path`: 파일 경로 (인라인 코멘트인 경우)
- `line` / `original_line`: 라인 번호
- `in_reply_to_id`: 스레드 관계 (리플인 경우)
- `user.login`: 작성자
- `created_at`: 작성 시간

#### 1-3. 미해결 코멘트 필터링

다음 기준으로 미해결 코멘트를 식별한다:

**미해결로 판단하는 조건:**
- 리플이 달리지 않은 인라인 코멘트
- 마지막 리플이 리뷰어의 것인 스레드 (대응이 안 된 상태)
- `suggestion` 블록이 포함되어 있지만 아직 적용되지 않은 코멘트
- 본문에 `[P1]`, `[P2]`, `[P3]` 등 우선순위 태그가 있는 코멘트

**이미 해결된 것으로 판단하는 조건:**
- 마지막 리플이 PR 작성자의 것이고, "수정 완료", "반영했습니다" 등의 표현 포함
- GitHub에서 "Resolved" 처리된 코멘트 (`resolved` 필드 확인 — 단, API에서 직접 제공하지 않으므로 GraphQL 사용)

GraphQL로 resolved 상태 확인:
```bash
gh api graphql -f query='
  query {
    repository(owner: "<owner>", name: "<repo>") {
      pullRequest(number: <PR번호>) {
        reviewThreads(first: 100) {
          nodes {
            isResolved
            comments(first: 10) {
              nodes {
                id
                databaseId
                body
                path
                line
                author { login }
              }
            }
          }
        }
      }
    }
  }
'
```

### 2. 코멘트 분류 및 타당성 분석

수집한 미해결 코멘트 각각에 대해 다음을 수행한다:

#### 2-1. 코멘트 유형 분류

| 유형 | 설명 | 예시 |
|------|------|------|
| **버그/오류 지적** | 코드/문서의 실제 오류 | "이 함수는 null을 처리하지 않습니다" |
| **개선 제안** | 더 나은 방법 제안 | "여기서 Map 대신 Set을 쓰면 성능이 좋습니다" |
| **스타일/컨벤션** | 코딩 스타일 관련 | "변수명을 camelCase로 변경해주세요" |
| **질문/확인** | 의도나 이유를 묻는 코멘트 | "이 로직의 의도가 뭔가요?" |
| **구조/설계** | 아키텍처나 설계 관련 | "이 모듈의 의존 방향이 역전되어 있습니다" |
| **문서 보완** | 문서 내용 수정/추가 요청 | "버전 정보를 명시해주세요" |
| **Suggestion** | GitHub suggestion 블록 | 코드 수정 제안 |

#### 2-2. 타당성 분석

각 코멘트에 대해 다음을 판단한다:

**타당한 지적 (수정 필요):**
- 실제 버그나 오류가 맞는 경우
- 프로젝트 컨벤션에 맞지 않는 경우
- CLAUDE.md 등 프로젝트 규칙에 위반되는 경우
- 보안 취약점이 실제로 존재하는 경우
- suggestion이 합리적인 경우

**부분적으로 타당한 지적 (수정 + 설명):**
- 지적은 맞지만 제안된 해결책이 다른 방향일 때
- 맥락을 고려하면 현재 구현이 더 적절할 때
- 범위(scope) 밖의 개선이지만 후속 작업으로는 타당할 때

**타당하지 않은 지적 (반론):**
- 오해에 기반한 지적
- 프로젝트의 의도적 결정에 반하는 지적
- 이미 다른 곳에서 처리되고 있는 사안

### 3. 대응 실행

#### 3-A. 수정이 필요한 경우

1. **PR 브랜치로 체크아웃** (현재 브랜치가 다른 경우)
   ```bash
   git checkout <PR-head-branch>
   ```

2. **수정 계획 수립**: 각 코멘트에 대한 대응 방안을 정리한다
   - 어떤 파일의 어느 부분을 수정할지
   - suggestion 블록이 있으면 해당 내용을 그대로 적용할지
   - 어떤 커밋 메시지를 사용할지

3. **사용자 확인**: `AskUserQuestion` 도구를 사용하여 승인을 받는다
   - 질문: "위 계획대로 코드/문서를 수정하고 커밋해도 괜찮을까요?"
   - 옵션: "네, 진행하세요" / "수정이 필요합니다"
   - 계획을 먼저 명확히 보여준 후 질문한다

4. **코드/문서 수정**: 승인받은 계획에 따라 파일을 수정한다
   - suggestion 블록이 있으면 해당 내용을 그대로 적용
   - 그 외에는 지적의 의도에 맞게 수정

5. **커밋**: 수정 사항을 커밋한다
   ```
   fix: PR 리뷰 코멘트 반영 - <간략한 설명>
   ```
   - 여러 코멘트를 한 커밋에 묶되, 논리적으로 분리되는 경우 별도 커밋

6. **푸시**: 리모트에 반영
   ```bash
   git push
   ```

#### 3-B. 반론이 필요한 경우

반론은 다음 형식으로 작성한다:

```markdown
<반론 요약 (1줄)>

<근거 설명 (2-3줄)>
- 구체적 파일/라인 참조
- 프로젝트 컨벤션이나 설계 의도 인용
- 필요시 공식 문서/표준 참조
```

### 4. 코멘트별 리플 작성

각 미해결 코멘트에 대해 GitHub API로 리플을 등록한다.

#### 4-1. 인라인 코멘트에 리플

```bash
gh api repos/<owner>/<repo>/pulls/<PR번호>/comments \
  --method POST \
  -f body="<리플 내용>" \
  -F in_reply_to=<원본_코멘트_id>
```

#### 4-2. 일반 코멘트에 리플

```bash
gh api repos/<owner>/<repo>/issues/<PR번호>/comments \
  --method POST \
  -f body="<리플 내용>"
```

#### 리플 본문 형식

**수정 완료 시:**
```markdown
수정했습니다. <커밋SHA 앞 7자리>에서 반영했습니다.

<수정 내용 간략 설명>
```

**부분 수정 + 설명 시:**
```markdown
부분적으로 반영했습니다. <커밋SHA 앞 7자리>

<수정한 부분 설명>

다만 <반론 부분>에 대해서는 <근거>로 현재 구현을 유지했습니다.
```

**반론 시:**
```markdown
의도적인 결정입니다.

<근거 설명>

필요하다면 후속 PR에서 논의하겠습니다.
```

**후속 작업으로 이관 시:**
```markdown
타당한 지적입니다. 다만 이 PR의 범위를 벗어나므로 후속 작업으로 이관합니다.

<!-- TODO: <이슈 제목> -->
```

### 5. 전체 상태 리플

모든 코멘트를 처리한 후, PR에 전체 상태를 요약하는 코멘트를 남긴다:

```bash
gh api repos/<owner>/<repo>/issues/<PR번호>/comments \
  --method POST \
  -f body="<요약 코멘트>"
```

요약 코멘트 형식:
```markdown
## 리뷰 코멘트 대응 완료

| 코멘트 | 대응 | 커밋 |
|--------|------|------|
| [P8] 핵심 의존성 버전 명시 | 수정 완료 | `abc1234` |
| [P3] MongoDB 스타일 _id | 수정 완료 | `abc1234` |
| [P9] ESLint 설정 형식 | 반론 (의도적 결정) | — |

**수정:** N건 | **반론:** N건 | **후속 이관:** N건
```

### 6. 결과 보고

사용자에게 다음을 출력한다:
- 전체 미해결 코멘트 수
- 처리 결과 (수정 / 반론 / 후속 이관) 건수별 요약
- 수정된 파일 목록과 커밋 SHA
- PR URL

## Guardrails

- **수정 전 반드시 사용자 확인**: 코드/문서 수정과 커밋 전에 반드시 수정 계획을 사용자에게 보여주고 `AskUserQuestion` 도구로 승인을 받는다. 일반 텍스트 질문이 아닌 `AskUserQuestion` 도구를 사용해야 한다
- **force push 금지**: 기존 커밋을 rebase하거나 amend하지 않는다. 항상 새 커밋으로 추가한다
- **자동 resolve 금지**: GitHub에서 코멘트를 자동으로 resolve 처리하지 않는다. 리뷰어가 직접 resolve하도록 남겨둔다
- **과도한 수정 금지**: 리뷰 코멘트의 범위를 벗어나는 추가 수정을 하지 않는다
- **예의 바른 어조**: 반론 시에도 공격적이지 않은 어조를 유지한다
- **리뷰어 태그**: 리플에 리뷰어를 @멘션하지 않는다 (GitHub이 자동 알림 처리)
- **브랜치 보호**: PR 브랜치가 아닌 다른 브랜치를 수정하지 않는다
