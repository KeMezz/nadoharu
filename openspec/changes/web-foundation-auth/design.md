## Context

현재 `apps/api`에는 인증 기능이 구현되어 있으며, GraphQL `createUser(input)`, `login(input)`, `me`를 제공한다. 로그인 성공 시 토큰은 응답 본문이 아닌 httpOnly `accessToken` 쿠키로 전달된다.

반면 `apps/web`는 초기 스켈레톤 상태라 인증 화면/가드/세션 처리가 사실상 비어 있고, 레거시 프론트(`nadoharu-front`)는 디자인 자산은 충분하지만 기존 데이터 계약(`snake_case`, `jwt_token` 응답 전제) 기반으로 작성되어 현재 API와 그대로 호환되지 않는다.

이 change의 목적은 "도메인 기능 구현 전에 재사용 가능한 인증 프론트 기반"을 만드는 것이다. 즉, 디자인은 레거시를 참고하되 인증 계약은 현재 백엔드 스펙을 단일 기준으로 맞춘다.

## Goals / Non-Goals

**Goals:**

- 레거시 톤을 유지한 로그인/회원가입 UX를 `apps/web`에 정착한다.
- 인증 데이터 계약을 현재 API 스키마 기준으로 통일한다.
- 토큰 저장 전략을 httpOnly 쿠키 단일 모델로 고정한다.
- 공개/보호 라우트 전환 규칙과 인증 에러 표시 규칙을 표준화한다.
- 후속 기능 change가 재사용할 수 있는 auth 기반(클라이언트/가드/테스트 패턴)을 확립한다.

**Non-Goals:**

- Apple/Kakao/GitHub 소셜 로그인 구현
- post/comment/friend/chat/notification 화면 구현
- 백엔드 인증 도메인 로직 자체 변경
- 레거시 코드의 1:1 복붙 이식
- 루트 랜딩 페이지(로그인/회원가입 동선 포함) 디자인 및 콘텐츠 구성

## Decisions

### 1) 인증 계약의 단일 기준은 현재 API 스키마로 고정

- 선택: 프론트는 `createUser(input)`, `login(input)`, `me`를 기준으로 구현한다.
- 이유: 이미 구현/테스트된 백엔드 계약을 기준으로 삼아야 후속 기능 확장 시 계약 리스크가 줄어든다.
- 대안 검토:
  - 레거시 필드명(`username`, `account_id`, `jwt_token`) 유지: 백엔드 어댑터 계층이 커지고 중복 계약이 생겨 장기 유지보수 비용이 증가한다.

### 2) 세션의 Source of Truth는 httpOnly `accessToken` 쿠키

- 선택: 토큰을 `localStorage`/전역 상태에 저장하지 않는다.
- 이유: XSS 노출면을 줄이고, 백엔드 `auth-guards`/`jwt-token-management` 스펙과 일치한다.
- 대안 검토:
  - 브라우저 저장소 기반 JWT: 구현은 단순하지만 보안·정책 일관성이 떨어진다.

### 3) 웹-API 통신은 동일 진입점 기준으로 표준화

- 선택: `apps/web`에서 인증 요청 진입점을 단일화한다(환경별 URL 분기 최소화, 쿠키 전달 규칙 일관화, `credentials: include` 또는 동등 설정 강제).
- 이유: 로그인 쿠키 전달, 보호 요청 인증, E2E 환경을 한 방식으로 맞춰야 기능별 화면 구현 때 인증 버그를 반복하지 않는다.
- 대안 검토:
  - 화면별로 직접 API 호출 방식 혼용: 라우트마다 쿠키/에러 처리 차이가 발생하고 디버깅 비용이 커진다.

### 4) 라우트 가드는 "선검사(쿠키 존재) + 확정검사(me)" 이중 구조

- 선택: Next.js Middleware(서버 사이드)에서 httpOnly `accessToken` 쿠키 존재를 1차 검사하고, 이후 화면 진입 시 필요하면 클라이언트의 `me` 조회로 인증 상태를 확정한다.
- 이유: UX 응답성을 확보하면서도 만료/무효 토큰을 화면 진입 초기에 정리할 수 있다.
- 대안 검토:
  - 매 요청마다 `me` 강제 조회: 정확하지만 화면 전환 지연과 서버 부하가 증가한다.

### 5) 인증 에러는 코드 기반 매핑 테이블로 통일

- 선택: `INVALID_CREDENTIALS`, `ACCOUNT_TEMPORARILY_LOCKED`, `UNAUTHORIZED`를 사용자 메시지/행동(재시도, 로그인 이동)으로 매핑한다.
- 이유: 화면마다 임의 문구를 쓰는 것을 방지하고 QA 기준을 단순화한다.
- 대안 검토:
  - 화면별 개별 에러 처리: 메시지 일관성 저하, 테스트 케이스 중복 증가.

### 6) 레거시 이식은 "UI 재현 + 데이터층 재작성" 원칙

- 선택: 디자인/레이아웃/상호작용은 참고하되 GraphQL 타입/쿼리/액션은 신규 앱 구조에 맞게 다시 정의한다.
- 이유: 레거시 계약 불일치를 그대로 들고 오지 않고, 신규 모노레포 규칙(TDD, strict TS, Next App Router)에 맞출 수 있다.
- 대안 검토:
  - 레거시 코드 직접 이식: 초기 속도는 빠르지만 기술부채와 계약 불일치가 누적된다.

### 7) 루트 경로(`/`)는 본 change에서 고정하지 않고 별도 랜딩 change로 분리

- 선택: 본 change에서는 `/`를 로그인 진입점으로 고정하지 않는다. 루트 랜딩 페이지와 로그인/회원가입 진입 동선은 별도 change에서 설계한다.
- 이유: 인증 기반 구축(change 목적)과 랜딩 페이지 브랜딩/콘텐츠 설계를 분리해 범위를 안정적으로 유지한다.
- 대안 검토:
  - 본 change에서 `/`까지 확정: 진행 속도는 빠를 수 있으나 scope가 커져 auth 기반 작업의 완료가 지연될 수 있다.

### 8) 인증 성공 후 보호 영역 기본 진입점은 `/me`로 고정

- 선택: 본 change에서 인증 성공 후 기본 보호 진입 경로를 `/me`로 고정한다.
- 이유: 루트(`/`) 정책을 분리하더라도 로그인/공개 전용 라우트 리다이렉트의 기준점이 필요하며, 존재 보장이 어려운 임의 경로 선택으로 인한 404/리다이렉트 루프를 예방한다.
- 대안 검토:
  - 구현 시점 임의 선택(`/posts` 등): 경로 준비 상태에 따라 환경별 실패가 발생할 수 있다.

### 9) 인증 실패 메시지는 보수적 단일 문구 정책을 사용

- 선택: 인증 실패 시 사용자 노출 메시지는 코드별 상세 분기보다 단일 보수 문구를 기본으로 한다.
- 이유: 계정 존재 여부, 잠금 상태 등 내부 정보를 간접 노출할 가능성을 줄인다.
- 대안 검토:
  - 코드별 상세 문구 노출: UX는 친절하지만 보안 관점에서 정보 노출면이 증가할 수 있다.

### 10) 소셜 로그인 버튼은 외관만 제공하고 비활성 상태로 유지

- 선택: Apple/Kakao/GitHub 버튼은 화면에 표시하되 비활성 처리하고 "준비 중" 상태를 명확히 전달한다.
- 이유: 레거시 디자인 연속성을 유지하면서도 미구현 기능 오해를 줄인다.
- 대안 검토:
  - 버튼 미노출: 오해는 줄지만 레거시 디자인과 화면 일관성이 낮아질 수 있다.

```text
[Auth UI: /login, /sign-up]
          |
          v
[Web Auth Layer: contract + error mapping + session handling]
          |
          v
[GraphQL API: createUser/login/me]
          |
          v
[httpOnly accessToken cookie]
```

## Risks / Trade-offs

- [로그인 쿠키 전달 경로의 환경 차이] → 개발/운영에서 동일한 요청 진입점과 쿠키 정책을 먼저 명문화하고 E2E로 고정 검증
- [레거시 필드명 습관 잔존] → 스펙과 타입을 camelCase 기준으로 강제하고 PR 체크리스트에 계약 일치 항목 추가
- [가드 과잉으로 인한 초기 로딩 증가] → 1차 쿠키 검사 후 필요한 화면에서만 `me` 확정 조회
- [에러 문구 파편화] → 중앙 매핑 테이블을 단일 소스로 두고 화면은 매핑 결과만 사용
- [비활성 소셜 버튼에 대한 사용자 혼란] → 버튼에 "준비 중" 라벨/상태 설명을 함께 제공

## Migration Plan

1. 인증 계약/에러/세션 정책을 스펙으로 확정한다.
2. 로그인/회원가입 화면을 레거시 디자인 기준으로 이식하되 데이터층은 신규 작성한다.
3. 라우트 가드와 인증 상태 확정 흐름을 적용한다.
4. Vitest(폼/가드/에러 매핑) + Playwright(로그인 성공/실패/리다이렉트) 검증을 추가한다.
5. 후속 기능 change에서 공통 auth 기반을 재사용한다.

롤백 전략:

- 문제 발생 시 auth 기반 도입 범위를 `/login`, `/sign-up`으로 축소하고 보호 라우트 확장을 단계적으로 재적용한다.

## Open Questions

- 현재 결정 기준으로 본 change의 미해결 질문은 없음.
- 후속 change에서 루트 랜딩 페이지(로그인/회원가입 진입 동선 포함) 범위를 별도로 정의한다.
